## Socket 이전 실시간 통신 기술들
웹소켓은 HTTP의 실시간 양방향 통신을 위해 개발된 표준 기술로 
HTTP 표준 기술과의 호환을 기반으로 하고 있는 동시에 HTTP의 제약점을 해결하는 것을 목표로 나온 기술이다.

웹소켓과 HTTP 프로토콜은 모두 OSI 모델에서 제 7계층인 응용 계층에 위치하며 제 4계층인 TCP에 의존한다.

HTTP는 클라이언트인 웹브라우저가 웹서버에 새로운 내용이 있는지 주기적으로 요청하는 폴링 방식이라면
웹소켓은 클라이언트와 웹서버가 연결을 유지한 상태에서 웹서버가 클라이언트에게 데이터를 전송해주는 푸시(Push) 혹은 스트리밍 방식이다.

HTTP의 실시간 상호작용성이 떨어지는 문제를 해결하기 위해 HTTP를 변형한 기법 세 가지가 있다.
* HTTP Polling
* HTTP Long Polling
* HTTP Streaming

## 클라이언트 소켓과 서버 소켓
클라이언트 프로그램과 서버 프로그램은 각각 자신의 포트를 통해 통신해야 한다.<br>
연결을 할 때도 포트를 사용하고 데이터를 교환할 때도 포트를 사용한다.<br>
자바 프로그램 안에서 포트를 사용하기 위해서는 소켓을 이용해야한다.<br>
자바 안에서 소켓의 종류에는 서버 소켓과 클라이언트 소켓이 있다.<br>

### 서버 소켓(Server Socket)
서버 소켓은 말 그대로 서버 프로그램에서만 사용하는 소켓이다.<br>
서버 소켓은 클라이언트로 부터 연결 요청이 오기를 기다렸다가 연결 요청이 들어오면<br>
클라이언트와 연결을 맺고 다른 소캣을 만드는 일을 한다.<br>

### 클라이언트 소켓(Client Socket
클라이언트 소켓은 대기할 필요가 없기 때문에 바로 클라이언트 소켓을 생성한다.<br>
클라이언트 프로그램에서 클라이언트 소켓은 서버 프로그램으로 연결 요청을 하는 것과 데이터 전송을 하는 일을 한다.<br>

## 소켓 API 실행흐름
### 클라이언트 소켓 처리 과정
클라이언트 소켓(Client Socket)은 처음 소켓(Socket)을 [1] 생성(create)한 다음,<br>
서버 측에 [2] 연결(connect)을 요청한다. <br>
그리고 서버 소켓에 연결이 받아들여지면 데이터를 [3] 송수신(send/recv)하고, <br>
모든 처리가 완료되면 소켓(Socket)을 [4] 닫는다.(close)<br>

### 서버 소켓 처리 과정
소켓(Socket)을 [1] 생성(create)하고<br>
서버가 사용할 IP 주소와 포트 번호를 생성한 소켓에 [2] 결합(bind)시킨다.<br>
그리고 클라이언트로 부터 연결 요청이 수신되는지 [3] 주시(listen)하고,<br>
요청이 수신되면 요청을 [4] 받아들여(accept) 데이터 통신을 위한 소켓을 생성한다.<br>
일단 새로운 소켓을 통해 연결이 수립(Established)되면, 클라이언트와 마찬가지로 데이터를 [5] 송수신(send/recv)할 수 있다.<br>
마지막으로 데이터 송수신이 완료되면 소켓(Socket)을 [6] 닫는다.(close)<br>

<img src="https://github.com/yuwltn/yuwltn/blob/main/photo/socket.PNG" width ="700" height="400" >

## 클라이언트 소켓 프로그래밍(Client Socket Programming)
* socket()<br>
  * 클라이언트 소켓 생성
  * TCP 소켓 : 스트림(Stream) 타입, UDP 소켓 : 데이터그램(Datagram) 타입
  * 연결 대상(IP:Port) 지정하고 연결 요청 전달을 위해 connct() 호출
* connect()<br>
  * IP 주소와 포트 번호로 식별되는 대상(Target)으로 연결 요청<br>
  * 블럭(Block)방식으로 동작 : 연결 요청에 대한 결과가 결정되기 전에는 실행이 끝나지 않는다.
  * 성공하면 send()/recv() 호출
* send()/recv()<br>
  * send() : 연결된 소켓을 통해 데이터를 보낼 때
  * recv() : 데이터를 받을 때
  * send()/recv() 모두 블럭(Block) 방식으로 동작 : 실행 결과가 결정되기 전에 종료되지 않는다.
  * 특히 recv()는 데이터가 수신되거나 에러가 발생하기 전에는 실행이 종료 되지 않아서 한 번 실행되면 언제 끝날지 모른다.
  * 송수신이 완료되면 close() 호출하여 소켓을 닫는다.
* close()
  * 데이터 송수신이 필요 없게 되면 소켓을 닫는다.

## 서버 소켓 프로그래밍(Server Socket Programming)
* socket()<br>
  * 소켓 생성
* bind()<br>
  * 소켓들이 중복된 포트 번호를 사용하지 않도록 해당 소켓이 지정된 포트 번호를 사용할 것이라는 것을 운영체제에 요청하여
  * 운영체제가 소켓과 포트 번호를 결합한다.
  * 그래서 서버 소켓은 고정된 포트 번호를 사용하여 그 포트 번호로 클라이언트 요청을 받아들인다.  
* listen()<br>
  * 클라이언트에 의한 연결 요청이 수신될 때까지 대기
  * 요청이 수신되거나 에러가 발생하면 대기 상태를 종료하고 리턴
  * 리턴 값에 클라이언트의 요청에 대한 정보는 들어있지 않다.
  * 클라이언트의 요청 정보는 큐(Queue)에 쌓인다. : 아직 연결되지 않은 대기 상태
  * 대기 중인 요청을 큐로부터 꺼내와서 연겨을 완료하기 위해서는 accept() 호출
* accept()<br>
  * 실질적인 소켓 연결 수행
  * 데이터 통신을 위해 연결되는 소켓이 서버 소켓이 아니라 accept() 내부에서 새로 만들어지는 소켓이다.
  * 서버 소켓의 대기 큐에 쌓여있는 첫 번째 연결 요청을 매핑시킨다.
  * 다른 연결 요청을 처리하기위해 다시 대기(listen)하거나 서버 소켓을 닫는다.(close)
* send()/recv()<br>
  * 클라이언트와 동일
* close()<br>
  * 소켓 닫기


## References
* https://recipes4dev.tistory.com/153
* https://www.itfind.or.kr/publication/regular/weeklytrend/weekly/view.do?boardParam1=8034&boardParam2=8034
