## HTTP(HyperText Transfer Protocol)
HTTP는 W3 상에서 정보를 주고 받을 수 있는 프로토콜이다.<br>
주로 `HTML 문서`를 주고 받는데에 쓰인다. 주로 `TCP`를 사용하고 HTTP/3부터는 `UDP`를 사용하며,<br>
80번 포트를 사용한다. 1996년 버전 1.0, 그리고 1999년 1.1이 각각 발표되었다.

HTTP는 `클라이언트`와 `서버` 사이에 이루어지는 `요청/응답(request/response)` 프로토콜이다.<br>
예를 들면, 클라이언트인 웹 브라우저가 HTTP를 통하여 서버로부터 웹페이지(HTML)나 그림 정보를<br>
요청하면, 서버는 이 요청에 응답하여 필요한 정보를 해당 사용자에게 전달하게 된다.<br>
이 정보가 모니터와 같은 출력 장치를 통해 사용자에게 나타나는 것이다.

### HTTP 특징
HTTP를 통해 전달되는 자료는 `http:`로 시작하는 `URL(인터넷 주소)`로 조회할 수 있다.<br>
HTTP는 연결 상태를 유지하지 않는 `비연결성(Connectless)` 프로토콜이다. 이러한 단점을 해결하기 위해<br>
`쿠키`와 `세션`이 등장하였다.<br>

서버에 연결하고, 요청해서 응답을 받으면 연결을 끊어버린다. 이러한 작동 방식은 장점과 단점을 가진다.<br>
* 장점 : 불특정 다수를 대상으로 하는 서비스에 적합한 방식이다. 수십만명이 웹 서비스를 사용하더라도 <br>
  접속 유지는 최소한으로 할 수 있기 때문에, 더 많은 유저의 요청을 처리할 수 있다.
* 단점 : 연결을 끊어버리기 떄문에 클라이언트의 이전 상태를 알 수가 없다. 이러한 HTTP의 특징을<br>
  `Stateless`라고 하는데 `Connectless`로부터 파생되는 특징이라고 할 수 있다. <br>
  클라이언트의 이전 상태 정보를 알 수 없게 되면, 당장에 문제가 생긴다. <br>
  예들 들어 클라이언트가 과거에 로그인을 성공하더라도 로그 정보를 유지할 수가 없다.<br>
  HTTP는 `쿠키(cookie)`를 이용해서 이 문제를 해결하고 있다.<br>
  클라이언트와 상태 정보를 정보 조각 형태로 서버와 클라이언트(웹 브라우저)에 남기는데<br>
  이 정보 조각을 `Cookie`라고 한다. 서버는 쿠키를 이용해서 `세션 정보`를 관리한다.

## Requset(요청)
클라이언트가 서버에게 연락하는 것을 요청이라고 하며 요청을 보낼 때는 요청에 대한 정보를 담아 서버로 보낸다.

### 요청 메시지 구성
* 요청 내용
* 헤더
* 본문

### Method(메서드)
메서드는 요청의 종류를 서버에게 알려주기 위해서 사용한다.<br>
* GET : 자료를 `요청`할 때 사용(SELECT)
* POST : 자료의 `생성`을 요청할 때 사용(INSERT)
* PUT : 자료의 `수정`을 요청할 때 사용(UPDATE)
* DELETE : 자료의 `삭제`를 요청할 때 사용(DELETE)
* HEAD: (HTTP)헤더 정보만 요청한다. 해당 자원이 존재하는지 혹은 서버에 문제가 없는지를 확인하기 위해서 사용한다.
* OPTIONS : 웹 서버가 지원하는 메서드의 종류를 요청한다.
* TRACE: 클라이언트가 요청을 그대로 반환한다. echo 서비스로 서버 상태를 확인하기 위한 목적으로 주로 사용한다.

보통 웹 서비스들은 GET과 POST만을 이용하여 개발한다.<br>
왜냐하면 GET과 POST 만드로도 모든 종류의 요청을 표현할 수 있고 편하게 개발할 수 있고<br>
웹 브라우저로 DELETE, HEAD 등을 보내는 form이 없기 때문이다.

이렇게 명시적으로 메서드를 사용하지 않아도 웹 서비스 개발에 큰 문제는 없지만<br>
가능하면 CRUD를 명시하는게 좋지 않을까?

그렇다 Restful API 서버의 경우에는 GET, POST, DELETE, PUT을 명시적으로 구분한다.<br>
자원의 위치 뿐만아니라 자원의 할 일까지 명확히 명시할 수 있기 떄문에 Open API 서버를 만들기 위해서 널리 사용된다.

### 요청 메시지 예시
```
GET https://github.com/yuwltn HTTP/1.1                        // 요청 내용
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) ...     // 헤더
Upgrade-Insecure-Requests: 1
```

1. 요청 내용 <br>
* GET : HTTP Method
* https://github.com/yuwltn : 사이트 주소
* HTTP/1.1 : HTTP 버전

2. 헤더(두 번째 줄부터)<br>
두 번째 줄 부터는 헤더로 요청에 대한 정보를 담고 있다.<br>
User-Agent, Upgrade-Insecure-Requests 등등이 헤더에 해당되며 헤더의 종류는 매우 많다.

3. 본문(헤더에서 한 줄 띄고)<br>
본문은 요청을 할 때 함께 보낼 데이터를 담는 부분이다.<br>
현재 예시는 단순히 주소로만 요청을 보내고 있고 따로 데이터를 담아 보내지 않기 때문에
본문이 비어있다.

## Response(응답)
서버가 요청에 대한 답변을 클라이언트에게 보내는 것을 응답이라고 한다.

### 응답 메시지 구성
* 상태 표시 행(status line) : 상태 코드(status code)와 reson message를 포함한다.
* 응답 헤더필드
* 빈 줄(empty line)
* 기타 메시지 

### Status Code(상태 코드)
모두 숫자 세자리로 이루어져 있으며 크게 다섯가지 부류로 나눌 수 있다.

* 1XX(Informational) : 정보. 정보 교환.
* 2XX(Sucess) :  성공. 클라이언트가 요청한 동작을 수신하여 이해했고 승낙했으며 성공적으로 처리했음을 가리킨다.
* 3XX(Redirection) : 방향 바꿈. 자료의 위치가 바뀌었다. 
* 4XX(Client Error) : 클라이언트 오류. 클라이언트에 오류가 있음을 나타낸다. 주소를 잘못 입력하였거나 요청이 잘못 되었다.
* 5XX(Server Error) : 서버 오류. 서버의 오류로 올바른 요청을 처리할 수 없다.

### 응답 메시지 예시
```
HTTP/1.1 200 OK                      // 상태 표시 행
Connection: keep-alive               // 헤더
Content-Encoding: gzip
Content-Length: 35653
Content-Type: text/html;

<!DOCTYPE html><html lang="ko" data-reactroot=""><head><title ...
```

1. 상태 표시 행
첫 줄은 버전 상태코드 상태 메시지로 구성되어 있다. 200은 클라이언트의 요청이 성공적으로<br>
전달되었음을 표시한다.

2. 헤더(두 번째 줄부터)
두 번째 줄부터는 헤더로 응답에 대한 정보를 담고 있다.

3. 본문(헤더 뒤부터)
응답에는 대부분의 경우 본문이 있다. 보통 데이터를 요청하고 응답 메시지에는 요청한 데이터를 담아서<br>
보내주기 때문이다. 응답 메시지에 HTML이 담겨 있는데 이 HTML을 받아 브라우저가 화면에 렌더링한다.


# HTTP 버전
> HTTP 역사
> * HTTP/0.9 (1991년)
> * HTTP/1.0 (1996년)
> * HTTP/1.1 (1997년) : 표준 프로토콜 가장 많이 사용 중
> * HTTP/2.0 (2015년) : HTTP 1.1의 성능 개선 및 확장
> * HTTP/3.0 (진행중)

## HTTP 0.9
* HTTP 초기 버전을 구분하기 위해 부르는 버전이다.
* 요청은 `단일 라인`으로 구성되며, 리소스에 대한 Method는 `GET`만 존재한다.
* 응답도 극도로 단순하다.(파일 내용 자체로만 구성)
* HTTP 헤더도 없고, HTML 파일만 전송 가능했던 것이 특징이다.

## HTTP 1.0 
* HTTP `헤더` 개념이 도입되어 요청과 응답에 추가되었다.
* 메타데이터를 주고 받고, 프로토콜을 유연하고 확장 가능하도록 개선되었다.
* 버전 정보와 요청 Method가 함께 전송되기 시작했다.
* 상태 코드 라인도 응답의 시작부분에 추가되어 브라우저 요청의 성공과 실패 파악이 가능해졌다.(해당 결과에 대한 로컬 캐시 갱신 등의 사용이 가능해졌다.)
* Content-Type 도입으로 HTML 이외의 문서 전송이 가능해졌다.

한계
* `커넥션 하나`당 `요청 하나`와 `응답 하나`만 처리가 가능하다. -> HTTP 1.1에서 개선(PipeLining)

## HTTP 1.1 표준 프로토콜
* 지속 커넥션(Persistent connection) 추가
  * 지정한 TimeOut 동안 커넥션을 닫지 않는 방법을 통해 커넥션의 사용성이 높아졌다. 
* HTTP 파이프라이닝(Pipelining) 추가
  * 앞 요청의 응답을 기다리지 않고 순차적인 여러 요청을 연속적으로 보내고 그 순서에 맞춰 응답을 받는 방식이다.
  * 순차적으로 하나씩 요청/응답이 처리되는 기존 방식을 개선했다.
  * 하나의 커넥션에 여러개의 요청이 들어있을 뿐, 동시에 여러개의 요청을 처리해 응답으로 보내주는 것은 아니다.(`다중화(Multiplexing)`이 되지는 않는다.)
* Keep Alive 지원
  * 이미 연결되어 있는 TCP 연결을 재사용하는 기능
  * Handshake 과정이 생략되므로 성능 향상을 기대할 수 있다.
  * Keep Alive 유지시간은 연결된 소켓에 I/O Access가 마지막으로 종료된 시점에서 정의된 시간까지 Access가 없더라도 세션을 유지하는 구조이다. 즉 정의된 시간 내에 Access가 이루어진다면 계속 연결된 상태를 유지할 수 있다.
  * 정적자원(HTML, 이미지 파일 등)으로만 구성된 웹 서버에 Keep Alive를 사용할 경우 약 50%의 성능 향상을 보인다.
  * Kepp Alive 기능은 설계상 문제가 있기 때문에 HTTP/1.1 명세에서는 제외되었지만 한 번 생성된 커넥션을 재사용한다는 개념은 유지되었다.

한계
* Head Of Line blocking(HOL) -> HTTP 2.0에서 개선
  * 요청한 Request에 문제가 있어서, 응답이 늦어지면 2번째, 3번째에 요청한 Request의 응답도 같이 늦어진다.
* Header 구조의 중복 -> HTTP 2.0에서 개선
  * 연속된 요청의 헤더의 많은 중복이 발생한다.

## HTTP 2.0 
기존 HTTP 1.1 버전의 성능 향상에 초점을 맞춘 프로토콜이다.

* HTTP 메시지 전송 방식의 전환
  * 기존 : 일반 텍스트 형식
  * 개선 : `Binary Framing` 계층을 추가해서, 보내는 메시지를 `프레임(frame)`이라는 단위로 분할하고 추가적으로 `바이너리`로 `인코딩`을 한다. (바이너리 형식 사용으로 파싱 속도 및 전송 속도가 빠르고 오류 발생 가능성이 낮아진다.)
* 다중화(Multiplexing)
  * 기존 : HTTP 1.1의 Pipelining은 동시에 여러 요청을 처리해 응답하지 못하고 HOL Bloking 문제가 발생했다.
  * 개선 : 동시에 여러 요청을 처리하는 것이 가능해져 HOL Bloking 문제가 해결되었다.
    * 메시지가 프레임(frame)으로 나뉘어 전송되는데, 프레임은 각 요청마다 구분되는 Stream틀 통해 전달된다.<br>
      하나의 커넥션 안에 여러 개의 스트림을 가질 수 있게 되어 다중화가 가능해진다.
* Stream Prioritization
  * 리소스 간 우선순위를 설정하는 기능이다.
  * Stream에 우선순의를 부여해서 인터리빙되고 전달하는 것이 가능해진다.
* ServerPush 사용
  * 브라우저에게 필요한 리소스들을 서버가 Client에게 push해주는 기능이다.
  * 필요한 경우
    * 캐싱되지 않은 리소스를 받아올 때
    * 페이지에서 필요한 리소스가 페이지를 내려주는 서버에 있을 때
* Header 압축
  * 기존 : 연속된 요청의 경우, 많은 중복된 헤더의 전송으로 오버헤드가 많이 발생했음
  * 개선 : 요청과 응답의 헤더 메타데이터를 압축해서 오버헤드를 감소
  * 1) 전송되는 헤더 필드를 static dynamic table로 서버에서 유지
  * 2) 이전에 표시된 헤더를 제외한 필드를 허프만(huffman) 인코딩을 수행해서 데이터를 압축
  
HTTP 2.0 한계
* 각 요청마다 Stream으로 구분해서 병렬적으로 처리하지만, 결국 이에는 TCP 고유의 HOL blocking이 존재한다.
* 서로 다른 Stream이 전송되고 있을 때, 하나의 Stream에서 유실이 발생되거나 문제가 생기면 <br>
  결국 다른 Stream도 문제가 해결될 때까지 지연되는 현상이 발생되기 때문이다.
* 즉, 이러한 TCP의 태생적인 HOL Blocking을 해결하기 위해 QUIC/HTTP 3.0이 등장하였다.

## QUIC/ HTTP 3.0
* QUIC을 기반으로 나온 새로운 HTTP 메이저 버전이다.
* Google에서 개발한 UDP 기반의 전송 프로토콜(Quick UDP Internet Connections)이다. 
* Google에서 TCP의 구조적 문제로 성능 향상이 어렵다고 판단하여 UDP 기반을 선택하였다.
* QUIC은 TCP의 3-way handshake 과정을 최적화 하는 것에 초점을 두고 개발되었다.
* QUIC은 TCP의 Stream은 하나의 Chain으로 연결되는 것과 다르게 각 Stream 당 독립된 Stream Chain을 구성하여 
  TCP HOL Blocking을 해결하였다.
  
## References
* https://ko.wikipedia.org/wiki/HTTP
* https://velog.io/@surim014/HTTP%EB%9E%80-%EB%AC%B4%EC%97%87%EC%9D%B8%EA%B0%80
* https://www.joinc.co.kr/w/Site/Network_Programing/AdvancedComm/HTTP
* https://velog.io/@neity16/HTTP-HTTP-%EB%B2%84%EC%A0%84-%EB%B3%84-%ED%8A%B9%EC%A7%95
* https://goodgid.github.io/HTTP-Keep-Alive/
