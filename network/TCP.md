## TCP(Transmisson Control Protocol)
전송 제어 프로토콜(TCP)은 인터넷 프로토콜 스위트(IP)의 핵심 프로토콜 중 하나로,<br>
IP와 함께 TCP/IP라는 명칭으로도 널리 불린다.<br>

### 역할
TCP는 근거리 통신망이나 인트라넷, 인터넷에 연결된 컴퓨터에서 실행되는 프로그램 간에 <br>
일련의 옥텟을 안정적으로, 순서대로, 에러없이 교환할 수 있게 한다.<br>

### 특징
* TCP는 OSI 7Layer 중 4계층 전송 계층에 위치하고 네트워크의 정보 전달을 통제하는 프로토콜이자 
  인터넷을 이루는 핵심 프로토콜의 하나이다.
* TCP는 웹 브라우저들이 월드 워이드 웹에서 서버에 연결할 때 사용되며, 
  이메일 전송이나 파일 전송에도 사용된다.
* TCP는 동시제어가 가능하다. 이는 초기 요청이 작게 시작해도 컴퓨터들과 서버들의 대역폭의 깊이가 증가해도
  네트워크가 지원할 수 있다는 것을 뜻한다.

```
OSI 7 Layer 쉽게 이해하기
7 Layer - 응용(Application) : HTTP, SMTP, SNMP, FTP, 텔넷, NFS, NTP
6 Layer - 표현(Presentation) : XDR
5 Layer - 세션(Session) : TCP의 세션 관리 부분
4 Layer - 전송(Transport) : TCP, UDP, RTP, SCTP
3 Layer - 네트워크(Network) : IP, ICMP, IPsec, ARP, RIP, BGP
2 Layer - 데이터 링크(Data Link)
1 Layer - 물리(Physical)

Transport Layer(4 Layer)
전송 계층
송신자와 수신자의 논리적 연결(Connection)을 담당하는 부분으로, 신뢰성 있는 연결을 
유지할 수 있도록 도와준다. 즉 Endpoint(사용자) 간의 연결을 생성하고 데이터를 
얼마나 보냈는지 얼마나 받았는지, 제대로 받았는지 등을 확인한다.
TCP와 UDP가 대표적이다.

Network Layer(3 Layer)
네트워크 계층
IP(Internet Protocaol)이 활용되는 부분으로, 한 Endpoint가 다른 Endpoint로 
가고자 할 경우, 경로와 목적지를 찾아준다. 이를 Routing이라고 하며 
대역이 다른 IP들이 목적지를 향해 제대로 찾아갈 수 있도록 돕는 역할을 한다.
```

### TCP/IP
TCP/IP는 패킷 통신 방식의 인터넷 프로토콜 `IP`와 전송 조절 프로토콜인 `TCP`로 이루어져 있다.<br>
`IP`는 패킷 전달 여부를 보증하지 않고, 패킷을 보낸 순서와 받는 순서가 다를 수 있다.<br>
`TCP`는 IP 위에서 동작하는 프로토콜로, 데이터의 전달을 보증하고 보낸 순서대로 받게 해준다.<br>
HTTP, FTP, SWTP 등 TCP를 기반으로 한 많은 수의 애플리케이션 프토토콜들이 IP 위에서 동작하기 때문에,<br>
묶어서 TCP/IP로 부르기도 한다.

TCP/IP를 사용하겠다는 것은 `IP` 주소 체계를 따르고 IP Routing을 이용해 목적지에 도달하여
`TCP`의 특성을 활용해 송신자와 수신자의 논리적 연결을 생성하고 신뢰성을 유지할 수 있도록 하겠다는 것을 의미한다.

즉, TCP/IP를 말한다는 것은 송신자가 수신자에게 IP 주소를 사용하여 데이터를 전달하고
그 데이터가 제대로 갔는지, 너무 빠르지는 않았는지, 제대로 받았다고 연락은 오는지에 대한 이야기를 하는 것이다.

우리가 인터넷에서 무언가를 다운로드 할 때 중간에 끊기거나 빠지는 부분 없이 완벽하게 받을 수 있는 이유도
TCP의 이러한 특성 덕분이다.

TCP를 기반으로 하는 프로토콜들은 차후 언급할 TCP의 '3 way handshake'를 거친 후, 각자 프로토콜(Layer 7)에 기반한
교환 과정을 실시한다.

IP가 패킷들의 관계를 이해하지 못하고 그저 목적지를 제대로 찾아가는 것에 중점을 둔다면
TCP는 통신하고자 하는 양쪽 단말(endpoint)이 통신할 준비가 되었는지, 데이터가 제대로 전송되었는지,
데이터가 가는 도중 변질되지는 않았는지, 수신자가 얼마나 받았고 빠진 부분은 없는지 등을 점검한다.

이런 정보는 TCP Header에 담겨 있으며 SYN, ACK, FIN, RST, Source Port, Destination Port, 
Sequence Number, Window Size, Checksum과 같은 `신뢰성 보장`과 `흐름 제어`, `혼잡 제어`에 관여할 수 있는 요소들도
포함되어 있다. 또한 IP Head er와 TCP Header를 제외한 TCP가 실을 수 있는 데이터 크키를 `세그먼트(Segment)`라고 부른다.

[TCP Header]
<img src="https://github.com/yuwltn/yuwltn/blob/main/photo/TCPHeader.PNG" width="900" header="300" >


## TCP 3 way handshake
> TCP 연결 생성

TCP는 장치들 사이에 논리적인 접속을 성립(establish)하기 위하여 3 way handshake를 사용한다. <br>
TCP 3 way handshake는 TCP/IP 프로토콜을 이용해서 통신을 하는 응용프로그램이 데이터를 전송하기 전에<br>
먼저 정확한 전송을 보장하기 위해 상대방 컴퓨터와 사전에 세션을 수립하는 과정을 의미한다.

Client > Server : TCP SYN(Synchronize sequence numbers)<br>
Server > Client : TCP SYN ACK(Acknowledgment)<br>
Client > Server : TCP ACK<br>

### TCP 3 way handshaking 역할
양쪽 모두 데이터를 전송할 준비가 되었다는 것을 보장하고, 실제로 데이터 전달을 시작하기 전에<br>
한 쪽이 다른 쪽이 준비되었다는 것을 알 수 있도록 한다.<br>
양쪽 모두 상대편에 대한 초기 순차 일련번호를 얻을 수 있도록 한다.<br>

### TCP 3 way handshaking 과정
<img src="https://github.com/yuwltn/yuwltn/blob/main/photo/TCP3-way.PNG" width ="550" height="350" >

STEP1<br>
A 클라이언트는 B 서버에 접속을 요청하는 `SYN` 패킷을 보낸다. <br>
이때 A 클라이언트는 `SYN`을 보내고 `SYN/ACK` 응답을 기다리는 `SYN_SENT` 상태가 되는 것이다.

STEP2<br>
B 서버는 `SYN` 요청을 받고 A 클라이언트에게 요청을 수락한다는 `ACK`와 `SYN flag`가 설정된 패킷을 <br>
발송하고 A가 다시 `ACK`로 응답하기를 기다린다. 이때 B서버는 `SYN_RECEIVED` 상태가 된다.

STEP3<br>
> TCP 연결 종료

A 클라이언트는 B 서버에게 ACK을 보내고 이후로부터는 연결이 이루어지고 데이터가 오가게 되는 것이다.<br>
이때의 B 서버 상태가 `Established`이다.

## TCP 4 way handshake
TCP 4way handshake는 세션을 종료하기 위해 수행되는 절차

## TCP 4 way handshacking 과정 
<img src="https://github.com/yuwltn/yuwltn/blob/main/photo/TCP4way.PNG" width="500" height="400" >

STEP1<br>
클라이언트가 연결을 종료하겠다는 `FIN` 플래그를 전송한다.

STEP 2<br>
서버는 일단 확인 메세지를 보내고 자신의 통신이 끝날 때까지 기다리는데 이 상태가 `TIME_WAIT` 상태다.

STEP 3<br>
서버가 통신이 끝났으면 연결이 종료되었다고 클라이언트에게 `FIN` 플래그를 전송한다.

STEP 4<br>
클라이언트는 확인했다는 메세지를 보낸다.

그런데 만약 "Server에서 FIN을 전송하기 전에 전송한 패킷이 Routing 지연이나 패킷 유실로 인한 재전송 등으로<br>
인해 FIN 패킷보다 늦게 도착하는 상황"이 발생한다면 어떻게 될까?

클라이언트에서 세션을 종료시킨 후 뒤늦게 도착하는 패킷이 있다면<br>
이 패킷은 DROP되고 데이터는 유실될 것이다.

이러한 현상에 대비하여 클라이언트는 서버로부터 FIN을 수신하더라도 일정시간(default 240초) 동안<br>
세션을 남겨놓고 잉여 패킷을 기다리는 과정을 거치게 되는데 이 과정을 `TIME_WAIT`이라고 한다.

## TCP가 안정적인 네트워크를 보장하는데 4가지 문제점
1. 손실 : 패킷이 손실될 수 있는 문제 
2. 순서 바뀜 : 패킷의 순서가 바뀌는 문제
3. 혼잡 : 네트워크의 패킷 수가 과도하게 증가하는 문제 
4. 오버로드 : 수신측이 오버로드되는 문제

## 흐름제어(Flow control)
> `송신측(클라이언트)`과 `수신측(서버)` 사이의 `전송 속도`를 다룬다.

수신측이 송신측보다 속도가 빠른 것은 문제가 되지 않지만, 송신측이 수신측보다 속도가 빠르면 문제가 발생한다.<br>
수신측에서 수신된 데이터를 처리에서 윗 계층으로 서비스하는 속도보다 송신측에서 보내는 데이터 속도가 더 빠르다면,<br>
수신측에서 제한된 저장용량(일반적으로 큐)을 초과하여 이후에 도착하는 데이터의  `손실`을 가져올 수 있다.<br>
이렇게 되면 불필요하게 응답과 재전송의 데이터가 다시 송신측과 수신측 간에 빈번히 이동해야 한다.<br>
따라서 이러한 위험을 줄이기 위해 송신측의 데이터 전송량을 수신측에 따라 조절해야 한다.

두가지 방법이 있다.
### Stop and Wait
매번 전송한 패킷에 대해 확인 응답을 받아야만 그 다음 패킷을 전송하는 방법이다.<br>
패킷을 하나씩 보내기 때문에 비효율적인 방법이다.

### Sliding Window
수신측에서 설정한 윈도우 크기만큼 송신측에서 확인 응답없이 세그먼트를 전송할 수 있게 하여<br>
데이터 흐름을 동적으로 조절하는 제어 기법이다.<br>
송신 버퍼의 범위는 수신 측의 여유 버퍼 공간을 반영하여 동적을 바뀜으로서 흐름 제어를 수행한다.

* 동작 방식<br>
먼저 윈도우에 포함되는 모든 패킷을 전송하고, 그 패킷들의 전달이 확인되는 대로 
이 윈도우를 옆으로 옮김으로써 그 다음패킷들을 전송한다.

LastByteSent - LastByteAcked <= ReceivecWindowAdvertised
(마지막에 보내진 바이트 - 마지막에 확인된 바이트 <= 남아있는 공간) == 현재 공중에 떠있는 패킷 수

```
패킷(Packet) : 인터넷 내에서 데이터를 보내기 위한 경로 배정(라우팅)을 효율적으로 하기 위해서 데이터를
여러 개의 조각들로 나누어 전송하는데, 이 조각을 패킷이라고 한다.

버퍼 : 송신 측은 버퍼에 TCP 세그먼트를 보관한 후 순차적으로 전송하고, 수신 측은 도착한 TCP 세그먼트를
애플리케이션이 읽을 때까지 버퍼에 보관한다.

Window : 
일정량의 데이터. 
TCP/IP를 사용하고 있는 모든 호스트들은 송신하기 위한 것과 수신하기 위한 
2개의 Window를 가지고 있다. 호스트들은 실제 데이터를 보내기 전에 3 way handshaking을 통해 
수신 호스트의 receive `Window size`에 자신의 send `Window size`를 맞추게 된다.

Window size : 
TCP Header 내의 `Window size`를 사용해 한번에 받고/보낼 수 있는 데이터 양을 정한다.
아무래도 받는 측의 사정이 더 중요하다 보니 Window size는 수신자가 정한다. (3 way handshake 때 정한다.)
그리고 자신의 상황에 따라 Window size를 조절한다. 

Acknowledgment Number : 
자신이 지금까지 받은 데이터 양을 확인하여 송신자에게 보내는 것을 말한다.

Sequence Number : 
만약 수신자가 300번 째의 데이터를 받았으면 Acknowledment Number에 1을 추가하여 301을 보낸다.
300번까지 받았으니 301번부터 보내라는 뜻이다. 그리고 이 데이터에 순서를 표기한 것을 말한다.
```

## 혼잡제어(Congestion Control)
> `호스트`와 `라우터`를 포함한 보다 넓은 관점에서 전송 문제를 다룬다.

송신측의 데이터는 지역망이나 인터넷으로 연결된 대형 네트워크를 통해 전달된다.<br>
만약 한 라우터가 몰릴 경우, 자신에게 온 데이터를 모두 처리할 수 없게 된다.<br>
이런 경우 호스트들은 또 다시 재전송을 하게되고 결국 혼잡만 가중시켜 오버플로우나 데이터 손실을<br>
발생시키게 된다. 따라서 이러한 네트워크의 혼잡을 피하기 위해 송신측에서 보내는 데이터의 전송속도를<br>
강제로 줄이게 되는데, 이러한 작업을 혼잡제어라고 한다.

4가지 방법이 있다.
### AIMD(Additive Increase / Multiplicative Decrease)
처음에 패킷을 하나씩 보내고 이것이 문제없이 도착하면 window size를 `1씩 증가`시켜가며 전송하는 방법이다.<br>
패킷 전송에 실패하거나 일정 시간을 넘으면 패킷의 보내는 속도를 `절반`으로 줄인다.<br>
공편한 방식으로 여러 호스트가 한 네트워크를 공유하고 있으면 나중에 진입하는 쪽이 처음에는 불리하지만,<br>
시간이 흐르면 평형상태로 수렴하게 되는 특징이 있다.<br>
문제점은 초기에 네트워크의 높은 대역폭을 사용하지 못하여 오랜 시간이 걸리게 되고,<br>
네트워크가 혼잡해지는 상황을 미리 감지하지 못한다. <br>
즉, 네트워크가 혼잡해지고 나서야 대역폭을 줄이는 방식이다.

### Slow Start(느린 시작)
Slow Start 방식은 AIMD와 마찬가지로 패킷을 하나씩 보내면서 시작하고, 패킷이 문제없이 도착하면<br>
각각의 ACK 패킷마다 window size를 1씩 늘려준다. 즉, 한 주기가 지나면 window size가 `2배`가 된다.<br>
전송속도는 혼잡 현상이 발생하면 window size를 1로 떨어뜨리게 된다.<br>
처음에는 네트워크 수용량을 어느정도 예상할 수 있는 정보가 없지만, 한번 혼잡 현상이 발생하고 나면<br>
네트워크 수용량을 어느 정도 예상할 수 있다.<br>
그러므로 혼잡 현상이 발생하였던 window size의 절반까지는 2배씩 증가시키고 그 이후부터는 완만하게 1씩 증가 시킨다.

### Fast Retransmit(빠른 재전송)
빠른 재전송은 TCP의 혼잡 조절에 추가된 정책이다.<br>
패킷을 받는 쪽에서 먼저 도착해야 할 패킷이 도착하지 않고 다음 패킷이 도착한 경우에도 ACK 패킷을 보내게 된다.<br>
단, 순서대로 잘 도착한 마지막 패킷의 다음 패킷의 순번을 ACK 패킷에 실어서 보내게 되므로,<br>
중간에 하나가 손실되면 송신 측에서는 순번이 중복된 ACK 패킷을 받게 된다. 이것을 감지하는 순간<br>
문제가 되는 순번의 패킷을 재전송 해줄 수 있다.

**중복된 순번의 패킷을 `3개` 받으면 재전송**을 하게 된다. 약간 혼잡한 상황이 일어난 것이므로<br>
혼잡을 감지하고 window size를 줄이게 된다.

### Fast Recovery(빠른 회복)
혼잡한 상태가 되면 window size를 `반`으로 줄이고 `선형 증가`시키는 방법이다.<br>
이 방법까지 적용하면 혼잡 상황을 한번 겪고 나서부터는 순수한 AIMD 방식으로 동작하게 된다.

## 오류제어
TCP에서 오류를 파악하는 방법에는 두가지가 있다.
1. 수신측에서 송신측으로 명시적으로 NAK를 전송
2. 전송한 패킷에 대한 ACK가 오지 않거나 중복된 ACK가 전송될 때

2번은 송신측에서 전송한 데이터가 유실되거나 수신측에서 답한 ACK 패킷이 유실되거나 3개 이상의 패킷이 전달되었을 때 
오류 발생으로 파악한다는 뜻이다.

1번은 송신측에서 NAK를 확인하는 새로운 로직이 필요하기 떄문에 일반적으로 2번으로 오류를 인지한다.

### Stop And Wait
흐름제어에 나왔던 이 방법만으로도 기본적인 오류 제어가 가능하다.<br>
송신 측에서 패킷을 보내고, 보낸 패킷에 대한 응답이 오면 다음 패킷을 보내는 방식이기 때문에
보낸 패킷에 대한 응답이 없다면 다시 전송하면 된다.

하지만 만약 Sliding Window를 사용하는 경우 Stop and wait으로 오류를 제어하면 Sliding window를 사용하는
의미가 전혀 없어지기 때문에 재전송 기반의 오류 제어, `ARQ`를 사용한다.

### ARQ(Automatic Reqeat Request)
TCP는 기본적으로 재전송 기반의 오류 제어를 사용한다.<br>
즉, 통신 중에 어떤 오류가 발생하면 송신 측에서 수신 측으로 해당 데이터를 재전송하는 방식을 사용하여
오류 발생을 해결한다는 의미이다.

하지만 실제로 수많은 데이터를 주고 받아야 하는 네트워크 상황에서 이러한 재전송 방식은 그 자체로 비효율 적이기 때문에
이러한 재전송을 최대한 적게하는 여러 방식으로 TCP는 오류를 제어한다.

ARQ를 이용한 오류 제어 방식에는 크게 두가지가 있다.
#### Go Back N
송신측에서 여러 개의 데이터를 연속적으로 보내다가 오류가 발생하면, 오류가 발생한 데이터부터<br>
다시 재전송하는 방식을 사용한다.<br>
에러가 발생한 데이터 이후의 데이터는 모두 폐기하고 에러가 발생한 데이터를 송신측에 알린다. `NAK`<br>

하지만 이러한 방식 역시 이미 수신한 데이터를 폐기하고 다시 재전송해야 한다는 단점이 있다.<br>
이러한 단점을 보완하는 방법이 `Selective Reapeat`이다.

#### Selective Repeat
Selecive Repeat은 오류가 발생한 데이터만 골라서 재전송하는 방식이다.

하지만 데이터가 순서대로 쌓이다가 오류가 발생한 데이터를 뒤늦게 받게되면<br>
수신측의 버퍼에 순서가 보장되지 않는다는 단점이 있다.<br>
때문에 수신 버퍼에 대한 `재정렬`이 필요하고, 이는 필연적으로 또 다른 버퍼 공간을 필요로 한다는
단점이 있다.

## UDP(User Datagram Protocol)
TCP와 UDP는 모두 OSI 7 계층 중 전송 계층에서 사용되는 프로토콜이다.<br>
TCP는 반드시 클라이언트와 서버가 안정적으로 연결된 상태에서 데이터 전송이 일어나지만<br>
UDP는 데이터를 주고 받고자 할 때 안정적인 연결이 이루어 졌는지 별도의 검사 없이 데이터 전달이 이루어진다.

UDP는 비연결형 서비스이기 때문에, 연결을 설정하고 해제하는 과정이 존재하지 않는다.<br>
서로 다른 경로로 독립적으로 처리함에도 패킷에 순서를 부여하여 재조립을 하거나 흐름 제어 또는 혼잡 제어와 같은<br>
기능도 처리하지 않기에 TCP보다 속도가 빠르며 네트워크 부하가 적다는 장점이 있지만 신뢰성 있는 데이터의 전송을<br>
보장하지는 못한다.<br>
그렇기 때문에 신뢰성보다는 `연속성`이 중요한 서비스이다. 예를 들면 실시간 서비스(Streaming)에 자주 사용된다.

<img src="https://github.com/yuwltn/yuwltn/blob/main/photo/TCPUDP.PNG" width="550" height="400" >

## References
* https://ko.wikipedia.org/wiki/%EC%A0%84%EC%86%A1_%EC%A0%9C%EC%96%B4_%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C
* https://aws-hyoh.tistory.com/entry/TCPIP-%EC%89%BD%EA%B2%8C-%EC%9D%B4%ED%95%B4%ED%95%98%EA%B8%B0
* https://jsonsang2.tistory.com/17
* https://gyoogle.dev/blog/computer-science/network/%ED%9D%90%EB%A6%84%EC%A0%9C%EC%96%B4%20&%20%ED%98%BC%EC%9E%A1%EC%A0%9C%EC%96%B4.html
* https://steady-coding.tistory.com/507
* https://velog.io/@nnnyeong/Networking-TCP-vs-UDP
* https://mangkyu.tistory.com/15
