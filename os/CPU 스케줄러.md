## CPU 스케줄링
CPU 스케줄링이란 어떤 프로세스가 `CPU를 점유`할 것인지를 결정하는 것을 말한다.<br>
CPU 스케줄링의 목적은 시스템을 `효율적이고 빠르고 공정(fair)하게` 만드는 것이다.

## 선점(Preemtive) vs 비선점(Non-preemptive)
CPU 스케줄링에는 선점 방식과 비선점 방식이 있다.<br>
선점 방식은 프로세스가 아직 CPU를 더 점유할 수 있음에도 다른 프로세스에게 CPU 점유를 빼앗길 수 있는 방식이다.<br>
비선점 방식은 다른 프로세스가 CPU 점유를 빼앗지 못하고 사용이 끝날 때 까지 기다리는 방식이다. <br>

비선점 스케줄링이 일어나는 경우
* Running -> Waiting 상태 (ex. I/O 요청, 자식 프로레스 종료 - wait() 요청을 통해 종료)
* Running -> Terminate 상태 (ex. 부모 프로세스의 종료)

선점 스케줄링이 일어나는 경우
* Running -> Ready 상태 (ex. I/O 완료)
* Waiting -> Ready 상태 (ex. I/O 완료)
<br><br>

## 스케줄링 알고리즘
## FCFS(Fist Come First Served)
> 대표적인 비선점 스케줄링 방식

이름 그대로 먼저 도착한 프로세스를 먼저 처리하는 방식이다.<br> 
FCFS 방식은 가장 간단하고 공정한 방식이지만 대기 시간이 상대적으로 많다.<br> 
특히 가장 먼저 도착한 프로세스의 반환시간이 아주 긴 경우, 
뒤에 도착한 프로세스들이 오랫동안 기다려야하는 문제가 발생한다.
이를 마치 부하처럼 뒤따라서 기다리고 있는 것을 가리켜 호위 효과(Convoy Effect)라고 한다.

## SJF(Shortest - Job - First)
> 비선점 스케줄링 방식

SJF 방식은 가장 적은 작업 시간을 가지는 프로세스를 먼저 실행하는 스케줄링 방식이다.<br> 
이 방식을 사용하려면 각 프로세스의 작업 시간을 미리 예측할 수 있어야 한다.<br> 
여러 방법을 통해 프로세스의 작업 시간을 예측할 수 있지만 추가적인 오버헤드가 발생한다.<br> 

## SRTF(Shortest Remaining Time First)
> 선점 스케줄링 방식

최단 잔여 시간을 우선으로 하는 스케줄링이다.
진행중인 프로세스가 있어도 최단 잔여시간인 프로세스를 위해 sleep시키고 짧은 프로세스를 먼저 할당한다.
물론 추가적인 컨텍스트 스위칭 오버헤드가 발생한다.

## Priority Scheduling
> 선점 스케줄링 방식

각각의 프로세스에 우선 순위(보통 정수형 자료형을 사용)를 부여하고 우선 순위가 높은 순서대로 처리한다.
우선 순위는 시간 제한, 메모리 요구량, 프로세스의 중요성, 자원 사용 비용 등에 따라 달라질 수 있다.

이 방식은 우선 순위가 낮은 프로세스가 Ready Queue에서 대기하고 있는데, 새로 들어오는 프로세스가 계속 해당 프로세스보다
우선 순위가 높아서, CPU를 전혀 점유하지 못하는 `기아 상태(Starvation)`라는 문제점을 야기할 수 있다.
해결책으로는 어떤 프로세스가 Ready Queue에서 오래 머무르면 점진적으로 해당 프로세스의 우선 순위를 높여주는 aging 기법이 있다.

우선순위가 같을 경우, FCFS와 다를게 없다. (비선점, 선점 둘다 사용된다.)

## Round Robin
> 대표적인 선점 스케줄링 방식

라운드 로빈은 일정 시간이 지나면 다음 프로세스에게 CPU 점유를 넘기는 방식이다.
시분할(time sharing system)에서 많이 쓰는 방식이다. Time quantum(or time slice)를 정해놓고,
이 시간이 지나면 프로세스가 끝나지 않더라도 CPU 점유를 다음 프로세스로 넘긴다.

Time quantum이 무한에 가까워질수록 퍼포먼스는 FCFS와 같아진다.
Time quantum이 0에 가까워질수록 컨텍스트 스위칭이 매우 빈번하게 일어나므로 오버헤드도 증가한다.

## References
* https://wisdom-and-record.tistory.com/86?category=932460
* https://hyunah030.tistory.com/4
