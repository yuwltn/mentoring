## 동기(Synchronous)란?
동시에 똑같이 진행된다는 뜻이다. <br>
대표적인 동기의 예로는 은행이 있다. 송금을 하고 금액을 받는 상황에서 동시에 이루어져야 하기 때문이다.

## 비동기(asynchronous)란?
동시에 똑같이 진행되지 않는다는 뜻이다. 

## 동기 vs 비동기
동기는 설계가 간단하지만 결과가 나오지 않는다면 뒤의 작업을 진행할 수가 없다. <br>
비동기는 설계가 복잡하지만 결과가 나오지 않아도 기다리는 시간동안 병렬적으로 다른 작업을 수행할 수 있다.

---

## 동시성 문제
> 멀티 프로세스의 핵심적인 문제

동시성 문제란 두 개 이상의 세션이 공통된 자원에 대해서, 모두 읽고 쓰는 작업(Read -> Write)을 하려고 하는 경우 <br>
발생할 수 있는 문제를 가리킨다.

동시성 문제는 "완전한 해결"이 아닌 "적절한 제어"이다.<br>
`정확성`과  `활동성`을 어떻게 하면 모두 최대로 할 수 있을까에 대한 고민을 해야한다.<br>
`활동성(빠르기)`을 포기하면 `정확성`을 높일 수 있고, `정확성`을 포기하면 `활동성`을 높일 수 있다.

## Critical Section(임계영역)
임계 구역이란 둘 이상의 스레드가 동시에 접근해서는 안되는 공유 자원을 접근하는 코드의 일부를 말한다.

임계구역이 올바르게 실행되기 위해서는 세 가지 조건이 반드시 충족되어야 한다.<br>
* Mutual exclusive(상호 배타) : 임계 구역에는 오직 `하나의 스레드만` 진입해야 한다.
* Progress(진행) : 임계 구역을 실행 중인 스레드가 없다면, 다른 스레드가 임계 구역에 진입하는 것은 `유한 시간 내`에 결정되어야 한다.
* Bounded Waiting(한계 대기) : 어떤 프로세스가 임계 구역에 진입하기를 요청한 후에는 `유한 시간 내`에 진입이 허용되어야 한다.

## RaceCondition(경쟁상태)
공유 자원에 여러 스레드가 접근해 값을 수정하면 데이터의 일관성이 깨지게 되는데, 이를 `경쟁상태`라고 한다.<br>
이 경쟁 상태를 해결하기 위한 것이 `동기화`이다.

`동기화`는 어려 스레드가 동시에 실행되는 과정에서도 데이터의 일관성을 유지할 수 있돌고 임계 구역의 문제를 해결하고 <br>
프로세스/스레드의 실행 순서를 제어하는 작업을 말한다.

## Deadlock(교착상태)
정상적인 시스템에서 프로세스는 요청 -> 사용 -> 방출 순서로 자원을 사용한다.<br>
* 요청 : 프로세스는 자원을 요청한다. 요청이 즉시 처리되지 않는 경우(ex. 다른 프로세스가 해당 자원을 사용중인 경우) 프로세스는 자원을 얻을 때까지 대기해야 한다. 
* 사용 : 자원에 대한 작업을 실행한다.
* 방출 : 자원을 방출한다.

자원의 요청과 방출은 `시스템 콜`이다. 예시로는 디바이스의 request()와 release(), 파일의 open()과 close(), 메모리의 allocate()와 free()등이 있다.

OS가 관리 하지 않는 자원의 요청과 방출은 세마포어에 대한 wait() & signal() 또는 뮤텍스 락의 획득과 방출을 통해서 이루어질 수 있다.

커널이 관리하는 자원을 프로세스가 사용할 때는 시스템 테이블이 어떤 프로세스가 어떤 자원을 사용 중이고, 대기 중인지 등 모든 사항을 기록한다.

만약 아래와 같이 임의의 프로세스 P1과 P2가 각각 자원 A, B를 점유한 채로 B, A를 사용하기 위해 대기 중이라면<br>
<img src="https://github.com/yuwltn/yuwltn/blob/main/%EA%B5%90%EC%B0%A9%EC%83%81%ED%83%9C.jpg" width="400" height="300" ><br>
이 때 두 프로세스는 `교착 상태`에 있다고 말한다.<br>
P1은 자원 B에 대한 요청이 처리될 때까지 A를 점유하고 있고, P2는 자원 A에 대한 요청이 처리될 때까지 B를 점유하고 있다.<br>
결국 두 프로세스는 옴짝달싹 못한 채로 `무한히 대기`하게 된다.<br>

## Deadlock 발생 조건
교착 상태는 다음 네 가지 조건이 모두 만족할 때, `발생할 가능성`이 있다. <br>
주의할 점은 네 가지조건을 모두 만족할 때 반드시 일어나는 것이 아니라 발생할 가능성이 생기는 것이다.

* 상호 배제(mutual exclusion) : 최소 하나의 자원이 한 프로세스에 의해 상호 배제 상태로 점유되어야 한다.
* 점유하며 대기(hold-and-wait) : 프로세스는 최소 하나의 자원을 점유한 채로 다른 프로세스가 점유 중인 자원을 대기해야 한다.
* 비선점(no preemption) : 자원들을 선점할 수 없다. 즉 다른 프로세스가 점유 중인 자원을 강제로 뺏을 수 없고, 해당 프로세스가 자원을 자발적으로 방출할 때까지 기다리는 상태여야 한다.
* 순환 대기(circular wait) : 대기 중인 프로세스, 점유 당하고 있는 자원의 관계가 원형을 이루어야 한다. 아래 그림 참조
<img src="https://github.com/yuwltn/yuwltn/blob/main/circularWait.jpg" width="350" height="300" >

## Dead lock 해결 방법
교착상태 문제를 해결하는 방법은 크게 네 가지이다.
* 예방(Prevention)
* 회피(Avoidance)
* 탐지(Detection)
* 무시(Ignorance)

### 교착상태 예방
> 조건 원천 차단

교착상태 예방은 교착상태 발생 조건 네 가지 중 적어도 하나가 성립하지 않도록 보장하는 방법들이다.<br>
* Mutual exclusion
  * 자원에 대한 상호 베제를 인정하지 않는다.
  * 읽기 전용 파일 등의 자원은 공유가 가능하기 때문에 교착 상태가 일어날 수 없다.
  * 근데 애초에 공유가 불가능한 자원이 존재할 수 있기 때문에 이 방법만으로 모든 교착상태를 예방하는 것은 불가능하다.
* Hold-and-Wait
  * 프로세스가 자원을 요청하려면 다른 자원들을 가지고 있지 않다는 것을 보장한다.
  * 두가지 프로토콜이 가능한데 첫 번째 방법은 프로세스가 실행되기 전에 반드시 모든 자원을 요청하여 할당받게 하는 것이고,
  * 두 번째는 프로세스가 자원을 전혀 갖고 있지 않을 때만 자원을 요청할 수 있도록 강제하는 것이다.
  * 이 방식의 단점은 자원 활용률이 저하되고 기아 상태가 발생할 수 있다는 점 등이 있다.
* No Preemption
  * 자원을 선점 가능하게 한다. 즉, 어떤 프로세스가 하나의 자원을 점유하고 있는 상태에서 즉시 할당할 수 없는 다른 자원(무조건 대기해야 하는 자원)에 대해 요청을 하면, 현재 점유 중인 자원이 선점되게 하는 것이다. 
  * 이 역시 불가능한 상황이 존재한다.
* Circular Wait
  * 자원에 순서를 매기고 그 순서대로 접근하도록 강제함으로써 차단할 수 있다.

### 교착상태 회피
> 미리 파악, 교착 상태가 일어나지 않는 방향으로 자원 할당

교착상태 회피는 자원이 어떻게 요청될지에 대한 정보를 미리 파악하고 회피 알고리즘을 통해 교착상태가 일어나지 않도록 
자원을 할당하는 방식이다.

교착 상태 예방 방식에서 일어날 수 있는 이용률 저하와 처리율 감소를 피할 수 있다는 장점이 있다.
(회피 방식에 이용률 저하가 없는것 은 아니다, 모든 방식은 각기 장단점이 있으며 상황에 맞는 최적의 방식을 구현해야 한다.)

교착상태 회피 알고리즘에서는 각 프로세스가 자신이 필요한 자원의 최대치를 선언하도록 요구한다.(단일 프로세스 기준)<br>
이 값을 바탕으로 OS는 현재 요청이 들어온 프로세스에게 자원을 할당해야 할지, 대기시켜야 할지를 결정한다. 

### 교착상태 탐지
교착상태가 일어나는 것을 허용하는 시스템, 즉 교착상태 회피나 예방을 하지 않는 시스템이다.<br>
대신 교착상태가 일어난다면 교착상태를 탐지해 그에 대한 적절한 처리를 해준다.<br>
* 구성 방법
  * 탐지 알고리즘 : 시스템을 검사해 교착상태 발생 여부 결정
  * 복구 기법 : 교착상태로부터의 회복
* 탐지 알고리즘의 사용(언제 호출하는지)
  * 자원을 요청했는데 즉시 할당되지 못하고 있는 경우
  * 일반적으로 CPU 사용율이 40% 이하로 떨어지는 경우

### 교착상태 무시
> UNIX와 Windows를 포함한 대부분의 운영체제가 이 방법을 사용한다.

교착상태 무시란 말그대로 교착상태에 대해 아무런 대응도 하지 않는 것이다. 
교착상태는 자주 일어나지 않는데다가 예방 및 처리에 비용이 많이 들기 때문에 이 방법은 꽤나 경제적일 수 있다.
(만약 교착상태가 일어났다면 해당 프로세스를 강제 종료 후 재시작 하면 된다.)

## References
* https://velog.io/@hyeonyohwan/%EB%8F%99%EA%B8%B0-synchronous-vs-%EB%B9%84%EB%8F%99%EA%B8%B0-asynchronous
* https://wisdom-and-record.tistory.com/84?category=932460
* https://wisdom-and-record.tistory.com/88?category=932460
