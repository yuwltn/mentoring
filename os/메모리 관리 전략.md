CPU 스케줄링과 더불어 OS의 중요한 업무 하나가 바로 메모리 관리(Memory Management)이다.

메모리를 효과적으로 사용하기 위한 방법에 대해 OS는 두 가지 측면에서 접근한다.

* 메모리 낭비 없애기
* 가상 메모리(Virtual Memory)

OS가 낭비되는 메모리를 줄이기 위해 어떤 방법을 이용하는지 알아보기 전에 우선 프로그램이 메모리에 적재되는 과정을 살펴보자.

## 프로그램이 메모리에 올라가는 과정
메모리는 주소(address)와 데이터(data)로 구성된다고 할 수 있다. <br>

<img src="https://github.com/yuwltn/yuwltn/blob/main/photo/memory1.jpg" width="500" height="300" >

CPU가 필요한 주소를 보내면 메모리는 해당하는 주소의 데이터를 CPU로 보낸다.<br>
CPU가 연산한 값을 저장하기 위해 주소와 데이터를 함께 보내는 경우도 있으므로 데이터는 양방향으로
오고간다.

우리가 고수준 언어로 `Source file`을 작성하면 컴파일러가 이를 `Object file`로 컴파일 한다.<br>
`Object file`은 링커에 의해 다른 목적 파일과 합해져 `Executable file(실행 파일)`이 된다.<br>
프로그램이 동작할 때 메모리에 올라오는 파일이 바로 이 `Executable file(실행 파일)`이 된다.<br>

프로레스를 메모리에 로드하는 일은 OS가 담당하는데 이때 `MMU(Memory Management Unit)`라는 하드웨어가 
관여한다.

`MMU`는 CPU와 메모리 사이에서 주소를 `재배치(relocate)`하는 역할을 한다.<br>

<img src="https://github.com/yuwltn/yuwltn/blob/main/photo/mmu.jpg" width="550" height="300" >

예를 들어 CPU에서 0번지 주소를 내면, `재배치 레지스터(relocation register)`가 500을 더해주고,<br>
실제 메모리는 CPU가 500번지 메모리를 요구한 것으로 받아들인다.<br>
이때 CPU가 내는 주소를 `논리 주소(logical memory)`, 재배치된 주소를 `물리 주소(physical memory)`라고 한다.

이렇게 주소를 재배치하면 프로그램 입장에서는 자신이 어디에 로드되는지 알 필요가 없다.(사실 알 방법도 없다.) 그냥 프로그램이 0번지부터 시작한다고 가정하고 동작하면 MMU가 알아서 이를 물리 주소로 재할당 해주기 때문이다.

## 메모리 낭비 없애기
1. 동적 적재(Dynamic Loading)<br>
프로그램 실행에 반드시 필요한 루틴과 데이터만 적재하는 방법이다.<br>
모든 루틴(ex.오류처리)과 데이터(ex.배열)는 항상 사용하지 않고, 실행 시 필요하다면 그 때 해당 부분을 메모리에 적재한다.<br>

2. 동적 연결(Dynamic Linking)<br>
공통 라이브러리 루틴을 메모리에 중복으로 올리는 것은 낭비이기 때문에<br>
자주 사용되는 라이브러리 루틴은 메모리에하나만 적재하고, 다른 프로그램은 루틴 연결(link)을 런타임까지 미루다가
런타임에 동적으로 연결하면 메모리를 아낄 수 있다.

3. 스와핑(Swapping)<br>
메모리에 적재되어 있으나 현재 실행되지 않는 프로세스가 존재할 수 있다.<br>
이런 프로세스는 지금 당장 메모리 공간을 차지하고 있을 필요가 없기 때문에 <br>
이런 프로세스를 저장장치의 Swap 영역으로 잠시 내려놓았다가 프로세스가 다시 시작될 때 메모리에 올리는 것(Swap in/Swap out)을 스와핑이라고 한다.

## 메모리 관리 전략
### 1. 연속 메모리 할당<br>
프로세스를 메모리에 연속적으로 할당하는 기법이다.<br>
할당과 제거를 반복하다보면 흩어진 빈공간이 생겨나고 이로 인한 `외부 단편화`가 발생한다.<br>

연속 메모리 할당 알고리즘<br>
* 최초 적합(First-fit) : 가장 먼저 발견한 빈 공간에 프로세스 할당
* 최적 적합(Best-fit) : 할당 가능한 최소 크기의 빈 공간에 프로세스 할당
* 최악 적합(Worst-fit) : 할당 가능한 최대 크기의 빈 공간에 프로세스 할당

### 2. Paging(페이징)<br>
> 고정 크기

페이징은 프로세스를 일정한 크기로 잘라서 메모리에 할당하는 방법이다. <br>
이 때 잘린 프로세스 조각 하나를 `페이지`라고 한다.
`논리 메모리`는 고정 크기의 `페이지`로, `물리 메모리`는 고정 크기의 `프레임 블록`으로 나누어 관리한다.<br>
프로세스가 사용하는 공간을 `논리 메모리`에서 여러 개의 `페이지`로 나누어 관리하고, <br>
개별 페이지는 순서에 상관없이 `물리 메모리`에 있는 `프레임`에 매핑되어 저장한다.<br>
`MMU(Memory Management Unit)`의 재배치 레지스터 방식을 활용해 프로세스가 실제로는 조각조각 흩어진 채로 존재하는데도 CPU는 마치 프로세스가 연속된 메모리에 할당된 것처럼 인식하도록 한다.
내부 단편화가 발생한다.

### 3. Segmentation(세그멘테이션)<br>
> 가변 크기

페이징 기법과 반대로 논리 메모리와 물리 메모리를 같은 크기의 블록이 아닌, 서로 다른 크기의 논리적 단위인 `세그먼트`로 분할한다.
외부 단편화가 발생한다.

### 4. 세그멘테이션, 페이징 혼용 기법<br>
페이징과 세그멘테이션은 각각 내부 단편화와 외부 단편화가 발생한다.<br>
페이징과 세그멘테이션을 혼용해 이러한 단편화를 최대한 줄이는 전략이다.<br>
프로세스를 `세그먼트`로 나눈 다음 세그먼트를 다시 페이지 단위로 나누어 관리한다.<br>
매핑 테이블을 두 번 거쳐야 하므로 속도가 느려진다.

## 단편화(Fragmentation)
단편화는 메모리 공간이 충분함에도 불구하고 프로세스가 메모리에 적재되지 못해 메모리가 낭비되는 현상을 말한다.

1. 외부 단편화(External Fragmentation)<br>
프로세스는 메모리의 연속된 공간에 존재해야 하는데 이런 연속 메모리 할당(Cotiguous Memory Allocation)으로<br>
메모리의 빈공간이 불연속적으로 흩어져 있어서 빈공간을 합한 크기가 하나의 프로세스를 할당하기 충분한 크기 임에도<br>
프로세스를 항당하지 못하여 메모리가 낭비되는 현상을 말한다.

외부 단편화 해결 방법 : 페이징

2. 내부 단편화(Internal fragmentation)<br>
프로세스가 실제 사용해야 할 메모리보다 더 큰 메모리를 할당받아 메모리가 낭비되는 현상<br>

외부 단편화 해결 방법 : 세그멘테이션

3. 압축<br>
외부 단편화를 해소하기 위한 방법으로 흩어진 빈공간을 모으는 방법<br>
흩어진 빈공간을 합치는 과정에서 메모리에 적재된 프로세스를 정지시키고 한쪽으로 이동시키는 작업이 필요해 비효율적이다.<br>
또한 흩어진 빈공간을 어느 자유 공간을 기준으로 모을지 결정하는 알고리즘도 모호하다.


## References
* https://dheldh77.tistory.com/entry/%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C%EB%A9%94%EB%AA%A8%EB%A6%AC-%EA%B4%80%EB%A6%AC-%EC%A0%84%EB%9E%B5Memory-Management-Strategy
* https://wisdom-and-record.tistory.com/115?category=932460
* https://wisdom-and-record.tistory.com/116?category=932460
