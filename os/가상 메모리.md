## 가상 메모리
지금까지의 메모리 관리 전략은 프로세스 전체가 메모리 내에 올라와야 한다는 것을 전제로 하고 있다.<br>
그런데 반드시 모든 프로세스가 항상 메모리에 올라와 있어야 할까? 그렇지 않다.<br>
모든 프로세스가 항상 동시에 실행되는 것은 아니기 때문이다.<br>
가상 메모리는 프로세스 전체가 메모리 내에 올라오지 않더라도 실행이 가능하도록 하는 기법을 말한다.<br>

가상메모리는 물리 메모리로부터 사용자 관점의 논리 메모리를 분리시켜 주 메모리를 균일한 크기의 공간으로 구성된 엄청나게 큰 배열로 추상화 시켜준다. 
따라서 작은 메모리를 가지고도 큰 가상 주소 공간을 제공한다.

프로세스가 저장되는 공간을 보조 저장 장치까지 확장해서 프로세스를 보조 저장 장치에 저장하고
필요할 때만 메모리에 올려서 사용하면, 물리 메모리보다 더 큰 크기의 프로세스를 실행하는 것도 가능하다.

## 가상 주소 공간(VAS, Virtual Address Space)
가상 주소 공간은 각 프로세스당 주어지는 논리적인 공간이다.
가상 주소 공간의 크기는 물리 메모리(RAM)의 크기와는 독립적이며, 레지스터 크기에 종속적이다.

가상 주소 공간의 주소를 논리 주소라고 하는데, 모든 논리 주소가 반드시 물리적인 메모리의 물리 주소를 할당 받는 것은 아니다.

## 프로세스 간의 페이지 공유
프로세스의 주소 공간은 페이지(page)로 관리된다. MMU가 논리 주소를 물리 주소로 변환하는 과정에서 페이지와 프레임을 매핑하는 `페이지 테이블`로서 동작하는데, OS는 각 프로세스마다 하나의 `page table`을 할당한다. 페이지 테이블이 256개 이하인 경우 레지스터를 이용할 수 있지만 대부분의 경우 메인 메모리에 저장된다.

프로세스 간에 공유되는 페이지는 각 프로세스의 페이지 테이블에서 같은 프레임을 가리키도록 만들어 메모리 사용량을 줄일 수 있다. 각 프로세스는 `text(code)영역`와 `data 영역`을 다른 페이지로 분리해서 `text 영역(read-only)`을 다른 프로세스와 공유함으로써 메모리 활용도를 높일 수 있다.
물론 이렇게 의미 단위로 페이지를 분리할 경우 내부 단편화 현상이 더 많이 일어날 수 있다.

## Demand Paging(요구 페이징)
가상 메모리에서 프로그램 실행을 위해 초기에 필요한 것만 적재하려는 전략이다.
프로세스 내의 개별 페이지들은 페이저에 의해 관리된다.
프로세스 실행에 실제 필요한 페이지만 메모리에 적재해 사용되지 않을 페이지를 가져오는 시간과 메모리 낭비를 줄인다.

## Page fault trap(페이지 부재 트랩)
요구 페이징에서는 프로그램에 대한 모든 내용이 물리 메모리에 올라오지 않기 때문에
메모리에 없는 페이지에 접근하려할 때 페이지 부재 트랩이 발생한다.
페이지 부재 트랩이 발생하면 원하는 페이지를 저장 장치에서 가져오게 되고, 
만약 물리 메모리가 가득 차있는 상태라면 페이지 교체가 이루어진다.

* 페이지 부재 트랩 처리 과정
  1. 페이지 부재 트랩 발생
  2. 디스크에서 해당 페이지를 찾음
  3. 빈 페이지 프레임을 찾음
  4. 페이지 교체 알고리즘을 통해 Victim 페이지 선택
  5. Victim 페이지를 디스크에 저장
  6. 비워진 페이지 프레임에 새 페이지를 읽어옴
  7. 재시작
