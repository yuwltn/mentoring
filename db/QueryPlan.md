## DBMS(DataBase Management System)
DBMS는 데이터베이스를 관리하는 시스템이다.<br>
사용자와 DB사이에서 사용자의 요구에 따라 데이터를 생성하고 DB를 관리해주는 소프트웨어이다.
DBMS는 데이터를 `계층` 또는 `탐색` 형식으로 저장한다.
파일 시스템을 사용해 저장하며 따라서 테이블 간에는 아무런 관계가 없다.
데이터에 대한 많은 보안을 제공하지 않으며 정규화를 수행할 수 없어 데이터는 높은 중복성을 가질 수 있다.

## RDBMS(Relational DataBase Management System)
RDBMS는 관계형 모델을 기반으로하는 DBMS 유형이다.<br>
RDBMS의 테이블은 서로 연관되어 있어 일반 DBMS보다 효율적으로 데이터를 저장, 구성 및 관리할 수 있다.
정규화를 통해 데이터의 중복성을 최소화하며 트랜잭션을 수행하는 것이 더 쉽다.
데이터의 원자성, 일관성, 격리 및 내구성을 유지하며 데이터 무결성을 높인다.
MySQL, Oracle, MSSQL 등이 있다.

## 쿼리 실행 계획(Query Plan)
RDBMS에서 가장 복잡하면서 가장 중요한 것은 옵티마이저(Optimizer)가 쿼리를 어떻게 실행할지
실행 계획을 결정하는 부분이다.
PostgreSQL과 MySQL 모두 `EXPLAIN`이라는 SQL 구문을 이용해 쿼리 플랜을 확인할 수 있다.
그리고 성능 분석을 할 때는 보통 `ANALYZE`문까지 붙여서 실행 시간을 포함한 구체적인 실행 계획을
분석한다.

## 옵티마이저(Optimizer)란?
옵티마이저는 가장 효율적인 방법으로 SQL을 수행할 최적의 처리 경로를 생성해주는 DBMS의 핵심 엔진이다.
컴퓨터의 두뇌가 CPU인 것처럼 DBMS의 두뇌는 옵티마이저라고 할 수 있다.
개발자가 SQL을 작성하고 실행하면 소프트웨어 실행파일처럼 즉시 실행되는 것이 아니라 
옵티마이저(Optimizer)라는 곳에서 쿼리문을 어떻게 실행실지에 대해 여러가지 실행 계획을 세우게 된다.

### 옵티마이저 종류
* 규칙 기반 옵티마이저 : 실행 속도가 빠른 순으로 규칙을 먼저 세워두고 우선순위가 앞서는 방법을 채택하는 것 -> 이제는 안쓰임
* 비용 기반 옵티마이저 : 통계 정보(쿼리 대상 테이블의 레코드 수, 선택도 등)를 바탕으로 계산해서 비용이 가장 적을 것 같은 방향으로 실행 계획 생성 -> 대부분 이 방식 옵티마이저 사용(MySQL 포함)

## 실행 계획을 확인하는 방법
* EXPLAIN PLAN
* AUTOTRACE
* SQL TRACE

## 실행 계획을 해석하는 방법
실행 계획은 여러 가지 단계로 이루어져 있는데 이것을 스텝이라고 한다.
각각의 스텝에는 그 단계에서 어떤 명령이 수행되었고 총 몇건의 데이터가 처리되었으며
이 처리를 위해 얼만큼의 비용과 시간이 소요되었는지를 표시한다.

### 실행 계획 순서 읽기
실행 계획을 읽을 때는 규칙이 있다.
1. 위에서 아래로 읽어 내려가면서 제일 먼저 읽을 스텝을 찾는다.
2. 내려가는 과정에서 같은 들여 쓰기가 존재한다면 무조건 위에서 아래 순으로 읽는다.
3. 읽고자 하는 스텝보다 들여 쓰기가 된 하위스텝이 존재한다면, 가장 안쪽으로 들여쓰기 된 스텝을 시작으로 하여 한 단계씩 상위 스텝으로 읽어나온다.

<img src ="https://github.com/yuwltn/yuwltn/blob/main/photo/queryplan.PNG" width ="600" height="300">

출력된 실행 계획에서 위쪽에 출력된 결과일수록(ID 칼럼의 값이 작을수록) 쿼리의 바깥(Outer) 부분이나 먼저 접근한 테이블이고, 아래쪽에 출력된 결과일수록(ID 칼럼의 값이 클수록) 쿼리의 안쪽(Inner) 부분 또는 나중에 접근한 테이블에 해당된다.

<img src="https://github.com/yuwltn/yuwltn/blob/main/pho2/qupll.jpg" width="400" height="450">

### 실행 계획 해석하기
자식들의 좌측부터 차례대로 읽어주고 그 다음에 상위 부모로 올라가는 식으로 반복하면 된다.

<img src="https://github.com/yuwltn/yuwltn/blob/main/pho2/qupl.jpg" width="400" height="450">

실행 순서 : 5 -> 4 -> 3 -> 7 -> 2 -> 8 -> 1 -> 0 <br>

5 : PK_EMP 인덱스를 사용하여 INDEX RANGE SCAN을 하면서 조건에 만족하는 인덱스 블록과 키 값을 검색한 결과 반환
4 : 5번에서 읽은 ROWID를 기반으로 EMP 테이블로 이동하여 조건에 부합하는 결과를 반환
6 : PK_DEPTNO 인덱스에서 INDEX UNIQUE SCAN 방식으로 검색한 결과의 ROWID를 반환합니다.
3 : 4번과 6번에서 반환된 데이터들을 기준으로 NESTED LOOP JOIN 방식으로 4번에서 반환된 데이터의 숫자만큼 반복하여 조인한 결과를 반환합니다.
7 : DEPT 테이블도 4번과 같이 조건에 부합하는 결과를 반환합니다.
2 : NESTED LOOP JOIN 방식으로 3번과 같이 JOIN의 결과를 만들어줍니다.
8 : SALGRADE 서브쿼리를 실행합니다.
1 : 서브쿼리를 통해 해당 조건을 만족하는 데이터를 필터링하여 반환합니다.

### 실행 계획 분석하기
실행 계획을 분석하기 위해서는 SCAN이라는 용어를 알고 있어야 한다.
SCAN은 데이터를 읽는 작업을 말하는데 SCAN을 수행하는 방식을 접근 경로라고 한다.

SCAN 방법 3가지
* FULL TABLE SCAN : 테이블의 전체 데이터를 읽어 조건에 맞는 데이터를 추출하는 방식
* ROWID SCAN : ROWID를 기준으로 데이터를 추출하며 단일 행에 접근하는 방식 중에서 가장 빠르다.
* INDEX SCAN : 인덱스를 활용하여 원하는 데이터를 추출하는 방식

테이블에 데이터가 많지 않아 INDEX를 타야하는 시간 소요가 불필요하다고 느껴지거나
테이블에서 추출해야하는 데이터 양이 엄청 많다면 FULL TABLE SCAN을 하는 것이 유리할 수 있고
반대로 많은 데이터가 있는 테이블에서 내가 원하는 데이터를 추출해야 하는 상황이라면
INDEX SCAN을 하는 것이 좋다.

